# Elisa Architecture

Elisa is a kid-friendly IDE that orchestrates AI agent teams to build real software and hardware nuggets. Kids compose nugget specs using visual blocks (Blockly); the backend decomposes specs into task DAGs, executes them via Claude Code CLI agents, and streams results back in real-time.

## System Topology

```
frontend/ (React 19 + Vite)         backend/ (Express 5 + TypeScript)
+-----------------------+           +---------------------------+
| Blockly Editor        |  REST     | Express Server            |
| (BlockCanvas)         |---------->| POST /api/sessions/:id/*  |
|                       |           |                           |
| MissionControl        |  WS      | Orchestrator              |
| (TaskDAG, CommsFeed,  |<---------|  -> MetaPlanner (Claude)   |
|  Metrics, Deploy)     |  events  |  -> AgentRunner (CLI)      |
|                       |           |  -> TestRunner (pytest)    |
| BottomBar             |           |  -> GitService (simple-git)|
| (Git, Tests, Board,   |           |  -> HardwareService       |
|  Teaching)            |           |  -> TeachingEngine         |
+-----------------------+           +---------------------------+
                                              |
                                    spawns claude CLI subprocess
                                    per task (--output-format stream-json)
```

## Monorepo Layout

```
elisa/
  frontend/          React SPA - visual block editor + real-time dashboard
  backend/           Express server - orchestration, agents, hardware
  hardware/          ESP32 templates and shared MicroPython library
  docs/              Product requirements (elisa-prd.md)
```

No npm workspaces. Frontend and backend are independent Node.js projects.

## Data Flow: Build Session Lifecycle

```
1. User arranges blocks in Blockly editor
2. Click GO -> blockInterpreter converts workspace to NuggetSpec JSON
3. POST /api/sessions (create) -> POST /api/sessions/:id/start (with spec)
4. Backend Orchestrator.run():
   a. PLAN:    MetaPlanner calls Claude API to decompose spec into task DAG
   b. EXECUTE: Topological sort -> run ready tasks via AgentRunner (claude CLI)
                Each agent gets: role prompt + task description + context from prior tasks
                Agent output streams as JSON -> WebSocket events to frontend
                Git commit after each completed task
   c. TEST:    TestRunner executes pytest, parses results + coverage
   d. REVIEW:  Optional reviewer agent pass
   e. DEPLOY:  If ESP32: compile -> flash -> serial monitor
5. session_complete event with summary
```

Human gates can pause execution at any point, requiring user approval via REST endpoint.

## Communication Protocol

| Channel | Direction | Purpose |
|---------|-----------|---------|
| REST | client -> server | Commands: create session, start build, gate responses, question answers |
| WebSocket | server -> client | Events: task progress, agent output, test results, teaching moments, errors |

WebSocket path: `/ws/session/:sessionId`

Frontend dev server (Vite port 5173) proxies `/api/*` and `/ws/*` to backend (port 8000).

## Core Abstractions

### NuggetSpec
JSON schema produced by blockInterpreter from Blockly workspace. Drives the entire pipeline. Contains: goal, requirements, style, agents, hardware config, deployment target, workflow flags, skills, rules.

### Task DAG
Directed acyclic graph of tasks with dependencies. Generated by MetaPlanner. Executed in topological order by Orchestrator. Uses Kahn's algorithm (`utils/dag.ts`).

### Build Session
In-memory state for one execution run. Tracks: session ID, phase, tasks, agents, commits, events, teaching moments, test results, token usage. No database - everything lives in memory.

### Agent Roles
- **Builder**: Writes source code
- **Tester**: Writes and runs tests
- **Reviewer**: Reviews code quality
- **Custom**: User-defined persona

Each agent is a Claude Code CLI subprocess with role-specific system prompts injected from `backend/src/prompts/`.

## State Machine

```
idle -> planning -> executing -> testing -> reviewing -> deploying -> done
                       ^
                   human gates (pause/resume via REST)
```

## Key Patterns

- **Event-driven UI**: All frontend state updates flow through WebSocket event handlers. No polling.
- **Subprocess isolation**: Each agent task runs as a separate `claude` CLI process. No shared state between agents except via context summaries written to `.elisa/` in the workspace.
- **Context chain**: After each task, a summary is written to `.elisa/context/nugget_context.md`. Subsequent agents receive this as input, creating a chain of context.
- **Graceful degradation**: Missing tools (git, pytest, mpremote, serialport) cause warnings, not crashes.
- **No auth**: Local-only development tool. CORS locked to localhost.

## Storage

- **Session state**: In-memory `Map<sessionId, Session>`
- **Workspace**: Temp directory per session (`/tmp/elisa-nugget-{timestamp}`) containing generated code, tests, git repo, and `.elisa/` metadata
- **localStorage**: Workspace JSON, skills, and rules auto-saved in browser (`elisa:workspace`, `elisa:skills`, `elisa:rules`). Restored on page load.
- **Nugget files**: `.elisa` zip format for export/import (workspace + skills + rules + generated code)
- **No database**

## Hardware Path

ESP32 support via serialport library:
1. Detect boards by USB VID:PID (Heltec LoRa, ESP32-S3, CH9102)
2. Compile MicroPython via `py_compile`
3. Flash via `mpremote`
4. Serial monitor at 115200 baud, streamed to frontend via WebSocket

## Module-Level Documentation

Deeper context for each subsystem lives in CLAUDE.md files within each directory:
- `frontend/CLAUDE.md` - Frontend architecture, component tree, state management
- `backend/CLAUDE.md` - Backend architecture, services, API surface
- `backend/src/services/CLAUDE.md` - Service responsibilities and interactions
- `frontend/src/components/CLAUDE.md` - Component hierarchy and patterns

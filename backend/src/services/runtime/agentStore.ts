/**
 * In-memory agent identity store for the Elisa Agent Runtime.
 *
 * Compiles NuggetSpec into AgentIdentity, manages API keys,
 * and provides CRUD operations. Follows the same in-memory Map
 * pattern as sessionStore.ts.
 */

import { randomUUID, randomBytes } from 'node:crypto';
import type {
  AgentIdentity,
  ToolConfig,
  StudyConfig,
  ProvisionResult,
} from '../../models/runtime.js';
import type { NuggetSpec } from '../../utils/specValidator.js';
import { generateSafetyPrompt } from './safetyGuardrails.js';

// ── Safety Guardrails (PRD-001 Section 6.3) ──────────────────────────
// These are NON-NEGOTIABLE. Injected into every agent's system prompt
// regardless of what the kid's NuggetSpec contains.
// Generated by safetyGuardrails.ts — the single source of truth.

const SAFETY_GUARDRAILS = generateSafetyPrompt();

// ── Helpers ───────────────────────────────────────────────────────────

function generateApiKey(): string {
  return `eart_${randomBytes(24).toString('hex')}`;
}

/**
 * Synthesize a system prompt from NuggetSpec fields.
 * Safety guardrails are always appended and cannot be overridden.
 */
function synthesizeSystemPrompt(spec: NuggetSpec): string {
  const parts: string[] = [];

  // Agent identity
  const name = spec.runtime?.agent_name ?? spec.nugget?.goal ?? 'Assistant';
  parts.push(`You are ${name}.`);

  // Goal
  if (spec.nugget?.goal) {
    parts.push(`\nYour purpose: ${spec.nugget.goal}`);
  }

  // Description
  if (spec.nugget?.description) {
    parts.push(`\nContext: ${spec.nugget.description}`);
  }

  // Personality
  if (spec.style?.personality) {
    parts.push(`\nPersonality: ${spec.style.personality}`);
  }

  // Requirements
  if (Array.isArray(spec.requirements) && spec.requirements.length > 0) {
    const reqList = spec.requirements
      .map((r: any) => r.description)
      .filter(Boolean)
      .map((d: string) => `- ${d}`)
      .join('\n');
    if (reqList) {
      parts.push(`\nCapabilities and requirements:\n${reqList}`);
    }
  }

  // Behavioral tests (inform the agent about expected behaviors)
  const behavioralTests = spec.workflow?.behavioral_tests;
  if (behavioralTests && behavioralTests.length > 0) {
    const tests = behavioralTests
      .map((t) => `- When: ${t.when} → Then: ${t.then}`)
      .join('\n');
    parts.push(`\nExpected behaviors:\n${tests}`);
  }

  // Study mode instructions
  if (spec.knowledge?.study_mode?.enabled) {
    const sm = spec.knowledge.study_mode;
    parts.push(`\nStudy Mode is enabled with style: ${sm.style}, difficulty: ${sm.difficulty}.`);
    if (sm.style === 'quiz_me') {
      parts.push(`Quiz the student every ${sm.quiz_frequency} turns.`);
    } else if (sm.style === 'flashcards') {
      parts.push('Always ask a question first. Only provide the answer after the student responds.');
    } else if (sm.style === 'socratic') {
      parts.push('Guide the student to answers through questions. Avoid giving direct answers.');
    }
  }

  // Fallback response instruction
  const fallback = spec.runtime?.fallback_response ?? "I'm not sure about that — let me think...";
  parts.push(`\nWhen you cannot answer a question or retrieve relevant information, say: "${fallback}"`);

  // Safety guardrails — always last, always present
  parts.push(`\n${SAFETY_GUARDRAILS}`);

  return parts.join('\n');
}

/**
 * Extract tool configs from NuggetSpec portals.
 */
function extractToolConfigs(spec: NuggetSpec): ToolConfig[] {
  if (!Array.isArray(spec.portals)) return [];

  return spec.portals
    .filter((p: any) => p.id && p.name)
    .map((p: any) => ({
      id: p.id,
      name: p.name,
      description: p.description ?? '',
      parameters: p.capabilities ?? {},
    }));
}

/**
 * Extract study config from NuggetSpec knowledge block.
 */
function extractStudyConfig(spec: NuggetSpec): StudyConfig | null {
  const sm = spec.knowledge?.study_mode;
  if (!sm?.enabled) return null;

  return {
    enabled: true,
    style: sm.style ?? 'quiz_me',
    difficulty: sm.difficulty ?? 'medium',
    quiz_frequency: sm.quiz_frequency ?? 5,
  };
}

/**
 * Extract topic index from NuggetSpec.
 * Topics come from the goal, requirements, and backpack sources.
 */
function extractTopicIndex(spec: NuggetSpec): string[] {
  const topics: string[] = [];

  if (spec.nugget?.goal) {
    topics.push(spec.nugget.goal);
  }

  if (Array.isArray(spec.requirements)) {
    for (const r of spec.requirements) {
      if (r.description) topics.push(r.description);
    }
  }

  if (Array.isArray(spec.knowledge?.backpack_sources)) {
    for (const s of spec.knowledge.backpack_sources) {
      if (s.title) topics.push(s.title);
    }
  }

  return topics;
}

// ── Agent Store ───────────────────────────────────────────────────────

interface StoredAgent {
  identity: AgentIdentity;
  apiKey: string;
}

export class AgentStore {
  private agents = new Map<string, StoredAgent>();
  private runtimeUrl: string;

  constructor(runtimeUrl = 'http://localhost:8000') {
    this.runtimeUrl = runtimeUrl;
  }

  /**
   * Compile NuggetSpec into an AgentIdentity, generate API key, store it.
   */
  provision(spec: NuggetSpec): ProvisionResult {
    const agentId = randomUUID();
    const apiKey = generateApiKey();
    const now = Date.now();

    const identity: AgentIdentity = {
      agent_id: agentId,
      agent_name: spec.runtime?.agent_name ?? spec.nugget?.goal ?? 'Agent',
      system_prompt: synthesizeSystemPrompt(spec),
      greeting: spec.runtime?.greeting ?? `Hi! I'm ${spec.runtime?.agent_name ?? 'your agent'}. How can I help you?`,
      fallback_response: spec.runtime?.fallback_response ?? "I'm not sure about that — let me think...",
      topic_index: extractTopicIndex(spec),
      tool_configs: extractToolConfigs(spec),
      voice: spec.runtime?.voice ?? 'nova',
      display_theme: spec.runtime?.display_theme ?? 'default',
      study_config: extractStudyConfig(spec),
      created_at: now,
      updated_at: now,
    };

    this.agents.set(agentId, { identity, apiKey });

    return {
      agent_id: agentId,
      api_key: apiKey,
      runtime_url: this.runtimeUrl,
    };
  }

  /**
   * Update an existing agent's identity from a new NuggetSpec.
   * Preserves agent_id and created_at.
   */
  update(agentId: string, spec: NuggetSpec): void {
    const stored = this.agents.get(agentId);
    if (!stored) throw new Error(`Agent not found: ${agentId}`);

    const now = Date.now();
    stored.identity = {
      ...stored.identity,
      agent_name: spec.runtime?.agent_name ?? spec.nugget?.goal ?? stored.identity.agent_name,
      system_prompt: synthesizeSystemPrompt(spec),
      greeting: spec.runtime?.greeting ?? stored.identity.greeting,
      fallback_response: spec.runtime?.fallback_response ?? stored.identity.fallback_response,
      topic_index: extractTopicIndex(spec),
      tool_configs: extractToolConfigs(spec),
      voice: spec.runtime?.voice ?? stored.identity.voice,
      display_theme: spec.runtime?.display_theme ?? stored.identity.display_theme,
      study_config: extractStudyConfig(spec),
      updated_at: now,
    };
  }

  /**
   * Get an agent's identity by ID.
   */
  get(agentId: string): AgentIdentity | undefined {
    return this.agents.get(agentId)?.identity;
  }

  /**
   * Delete an agent and all associated data.
   */
  delete(agentId: string): boolean {
    return this.agents.delete(agentId);
  }

  /**
   * Validate an API key for an agent.
   */
  validateApiKey(agentId: string, apiKey: string): boolean {
    const stored = this.agents.get(agentId);
    if (!stored) return false;
    return stored.apiKey === apiKey;
  }

  /**
   * Check if an agent exists.
   */
  has(agentId: string): boolean {
    return this.agents.has(agentId);
  }

  get size(): number {
    return this.agents.size;
  }
}

// Export for testing
export { SAFETY_GUARDRAILS, synthesizeSystemPrompt, generateApiKey };
